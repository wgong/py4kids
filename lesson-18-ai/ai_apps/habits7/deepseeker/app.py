"""
Task Management App based on Stephen Covey's 7 Habits of highly effectively people

- 2024-11-10
    - download task, note

- 2024-11-03
    - V7
        - refactor
        - enhance password hashing

- 2024-11-02
    - V6
        - add note
        - before adding a task or note, query by user-key to prevent duplicates

- v5
    - verify user functionality
        - add_user() was defined twice by mistake, causing unexpected behavior: user not added
        - populate sample tasks in tests/sample-tasks-20.sql

- v4
    - ask Claude to add user login page

- v3
    - merge v1 and v2, incorporated streamlit-aggrid component by me

- v2
    - generated by DeepSeek 

- v1
    - generated by Claude 3.5 Sonnet

"""

import streamlit as st

import hashlib
import bcrypt
import re
from typing import Tuple, Optional
from glob import glob
import sqlite3
from datetime import datetime, date, timedelta
import pandas as pd
from st_aggrid import (
    AgGrid, GridOptionsBuilder, GridUpdateMode, DataReturnMode, JsCode
)

# init app
# =========================
st.set_page_config(
    page_title='Habits-7 Tasks',
    layout="wide",
    initial_sidebar_state="expanded",
)

def init_session_state():
    st.session_state['logged_in'] = False
    st.session_state['user_id'] = None
    st.session_state['username'] = None
    st.session_state['is_admin'] = False

# init session_state
if "username" not in st.session_state:
    init_session_state()

# constants
# =========================
# pages
STR_HOME = "Home"
STR_MANAGE_NOTE = "Manage Note"
STR_MANAGE_TASK = "Manage Task"
STR_HABITS_7_TASK = "7-Habits-Task View"
STR_EDIT_USER = "Edit User"

STR_ADD_USER = "Add User"
STR_MANAGE_USER = "Manage Users"
STR_ADMIN_JOB = "Admin Job"

MENU_ITEMS = [
    STR_HOME, 
    STR_HABITS_7_TASK, 
    STR_MANAGE_TASK,
    STR_MANAGE_NOTE, 
    STR_EDIT_USER,
]


# database related functionalities
# ========================================
DB_FILE = "habits7.sqlite"

# LOV
BLANK_STR_VALUE = ""
LIST_TASK_GROUP = ['Work', 'Personal']
LIST_Y_N = ["Y", "N"]
LIST_TASK_STATUS = ["ToDo", "Doing", "Done"]
LIST_PROGRESS = ["0%", "25%", "50%", "75%", "100%"]
LIST_TASK_TYPE = ["", "learning", "research", "project", "fun"]
LIST_NOTE_TYPE = ["", "learning", "research", "project", "journal"]

LABEL_REQUIRED = "(*)"

EXPORT_FILE_EXT = {
    "CSV" : "csv",
    "JSON" : "json",
}

# table names
TABLE_H7_USER = "habits7_user"
TABLE_H7_TASK = "habits7_task"
TABLE_H7_NOTE = "habits7_note"

# DDL for creating tables
CREATE_TABLE_DDL = {
    TABLE_H7_USER: f'''
    CREATE TABLE IF NOT EXISTS {TABLE_H7_USER} (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        email TEXT NOT NULL UNIQUE,
        username TEXT NOT NULL,
        password BLOB NOT NULL,
        is_admin INTEGER DEFAULT 0 CHECK(is_admin IN (0, 1)),
        is_active INTEGER DEFAULT 1 CHECK(is_active IN (0, 1)),
        profile TEXT,
        note TEXT,
        created_by TEXT,
        created_at TEXT,
        updated_by TEXT,
        updated_at TEXT
    )
    ''',

    TABLE_H7_TASK: f'''
    CREATE TABLE IF NOT EXISTS {TABLE_H7_TASK} (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        task_name TEXT NOT NULL,
        description TEXT,
        task_group TEXT DEFAULT 'Personal' CHECK(task_group IN ('','Work', 'Personal')),
        is_urgent TEXT DEFAULT 'N' CHECK(is_urgent IN ('Y', 'N')),
        is_important TEXT DEFAULT 'N' CHECK(is_important IN ('Y', 'N')),
        status TEXT DEFAULT '' CHECK(status IN ('', 'ToDo', 'Doing', 'Done')),
        pct_completed TEXT DEFAULT '0%' CHECK(pct_completed IN ('0%', '25%', '50%', '75%', '100%')),
        due_date TEXT,
        task_type TEXT DEFAULT '' CHECK(task_type IN ('', 'learning', 'research', 'project', 'fun')),
        note TEXT,
        created_by TEXT,
        created_at TEXT,
        updated_by TEXT,
        updated_at TEXT
    )
    ''',

    TABLE_H7_NOTE: f'''
    CREATE TABLE IF NOT EXISTS {TABLE_H7_NOTE} (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        note_name TEXT NOT NULL,
        url text,
        note_type TEXT DEFAULT '' CHECK(note_type IN ('', 'learning', 'research', 'project', 'journal')),
        note TEXT,
        tags TEXT,
        created_by TEXT,
        created_at TEXT,
        updated_by TEXT,
        updated_at TEXT
    )
    ''',

}

# user-key column config - used to prevent duplicates
USER_KEY_COLS = {
    TABLE_H7_USER: ["email", "username"],
    TABLE_H7_TASK: ["task_name", "task_type"],
    TABLE_H7_NOTE: ["note_name", "url", "note_type"],
}

def handle_export_csv(df, DATA_ENTITY="Task"):
    # add download button
    df_data = df.to_csv(index=False)
    st.download_button(
        label=f"Download {DATA_ENTITY}",
        data=df_data,
        file_name=f"{DATA_ENTITY}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
        mime="text/csv"
    )   

# For JSON export
def export_df_to_json(df, orient='records'):
    """
    Export DataFrame to JSON string.
    
    Args:
        df: DataFrame to export
        orient: JSON format orientation, common options are:
               - 'records' : list-like [{column -> value}, ... ]
               - 'split' : dict-like {'index' -> [index], 'columns' -> [columns], 'data' -> [values]}
               - 'table' : dict-like {'schema': {schema}, 'data': {data}}
    """
    return df.to_json(orient=orient, date_format='iso')

def handle_export_json(df, DATA_ENTITY="Task"):
    # add download button
    df_data = export_df_to_json(df)
    st.download_button(
        label=f"Download {DATA_ENTITY}",
        data=df_data,
        file_name=f"{DATA_ENTITY}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json",
        mime="application/json"
    )  

# For .xlsx (Excel 2007+)
def export_df_to_excel(df):
    # Requires openpyxl for .xlsx format
    from io import BytesIO
    output = BytesIO()
    with pd.ExcelWriter(output, engine='openpyxl') as writer:
        df.to_excel(writer, index=False)
    return output.getvalue()

def handle_export_xlsx(df, DATA_ENTITY="Task"):
    # add download button
    df_data = export_df_to_excel(df)
    st.download_button(
        label=f"Download {DATA_ENTITY}",
        data=df_data,
        file_name=f"{DATA_ENTITY}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx",
        mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    ) 

def handle_export(df, DATA_ENTITY="Task"):
    export_format = st.selectbox("Export Format", ["CSV", "Excel", "JSON"])
    if export_format == "Excel":
        handle_export_xlsx(df, DATA_ENTITY)
    elif export_format == "JSON":
        handle_export_json(df, DATA_ENTITY)
    else:
        handle_export_csv(df, DATA_ENTITY)

class DBConn(object):
    def __init__(self, db_file=DB_FILE):
        self.conn = sqlite3.connect(db_file)

    def __enter__(self):
        return self.conn

    def __exit__(self, type, value, traceback):
        self.conn.commit()
        self.conn.close()

def run_sql(sql_stmt, DEBUG_SQL=False):
    """ 
    Helper to execute SQL without parametrized columns.
    Otherwise, create cursor and call execute() API.

        con = sqlite3.connect(DB_FILE, check_same_thread=False)
        cur = con.cursor()
        cur.execute(sql_stmt)
        con.commit()

    Returns:
        df - pandas dataframe
    """

    if DEBUG_SQL:
        print(sql_stmt)

    with DBConn() as conn:
        if sql_stmt.lower().strip().startswith("select") or \
            sql_stmt.lower().strip().startswith("with"):
            return pd.read_sql_query(sql_stmt, conn)
            # read_sql_query is more efficient than read_sql

        c = conn.cursor()

        x = [s.strip() for s in sql_stmt.split(";") if s.strip()]
        if len(x) < 1: 
            return None 
        if len(x) > 1:
            c.executescript(sql_stmt)
            conn.commit()
            return None 
        
        df = None
        c.execute(sql_stmt)
        try:
            data = c.fetchall()
            if c.description is not None:
                columns = [description[0] for description in c.description]
                df = pd.DataFrame(data, columns=columns)
            conn.commit()
        except Exception as e:
            print(f"[ERROR-DB] run_sql():\n {str(e)}")

        return df


def ddl_to_label_dict(ddl, reserved_words=['if', 'not', 'exists', 'table', 'create', 'primary', 'constraint', 'foreign', 'references', 'DEFAULT']):
    # Convert reserved words to lowercase for case-insensitive comparison
    reserved_words = [word.strip().lower() for word in reserved_words if word.strip()]
    
    # Extract column definitions from DDL
    # This regex now captures column names that might include underscores
    column_defs = re.findall(r'(\w+(?:_\w+)*)\s+[\w()]+', ddl)
    
    # Function to convert snake_case to Camel Case
    def to_camel_case(string):
        return ' '.join(word.capitalize() for word in string.split('_'))
    
    # Create dictionary with column names as keys and camel-cased labels as values
    col_label_dict = {col: to_camel_case(col) for col in column_defs if col.lower() not in reserved_words}
    if "url" in col_label_dict:  # special
        col_label_dict.update({"url": "URL"})  
    return col_label_dict

COL_LABELS = {k: ddl_to_label_dict(v) for k,v in CREATE_TABLE_DDL.items() }

def create_tables():
    if check_table_state(TABLE_H7_USER):
        create_user_table()
    if check_table_state(TABLE_H7_TASK):
        create_task_table()
    if check_table_state(TABLE_H7_NOTE):
        create_note_table()

# Function to create user table
def create_user_table():
    sql_stmt = CREATE_TABLE_DDL[TABLE_H7_USER]
    run_sql(sql_stmt)

# Function to create task table
def create_task_table():
    sql_stmt = CREATE_TABLE_DDL[TABLE_H7_TASK]
    run_sql(sql_stmt)

# Function to create note table
def create_note_table():
    sql_stmt = CREATE_TABLE_DDL[TABLE_H7_NOTE]
    run_sql(sql_stmt)

def query_user_keys(key_data):
    """
    Input: key_data (dict) - 
        {
            "table_name": ... ,
            "user_key_1": ... ,
            ...... ,
            "created_by"
        }
    Returns: 
        id - None (when no row matched) else row_id
    """
    table_name = key_data.get("table_name", "")
    if not table_name:
        return None
    
    if table_name not in USER_KEY_COLS: 
        return None

    created_by = st.session_state['username']

    if table_name == TABLE_H7_USER:
        email = key_data.get("email", "")
        username = key_data.get("username", "")
        sql_stmt = f"""
            select id from {table_name}
            where created_by='{created_by}'
                and email='{email}'
                and username='{username}'
            ;
        """
    elif table_name == TABLE_H7_TASK:
        task_name = key_data.get("task_name", "")
        task_type = key_data.get("task_type", "")
        sql_stmt = f"""
            select id from {table_name}
            where created_by='{created_by}'
                and task_name='{task_name}'
                and task_type='{task_type}'
            ;
        """
    elif table_name == TABLE_H7_NOTE:
        note_name = key_data.get("note_name", "")
        note_type = key_data.get("note_type", "")
        sql_stmt = f"""
            select id from {table_name}
            where created_by='{created_by}'
                and note_name='{note_name}'
                and note_type='{note_type}'
            ;
        """
    with DBConn() as conn:
        df = pd.read_sql(sql_stmt, conn)
        if df is None or df.empty or df.shape[0] < 1:
            return None
        
        return df["id"].to_list()[0]


def sanitize_search_input(value):
    """Sanitize search input to prevent SQL injection"""
    if value is None:
        return ""
    return value.replace("'", "''")

# Function to check if the user is the first user (super-user)
# @st.cache_data
def is_first_user():
    sql_stmt = f"SELECT COUNT(*) FROM {TABLE_H7_USER}"
    df = run_sql(sql_stmt)
    if df is not None and not df.empty:
        count = df.iloc[0,0]
        return count == 0
    else:
        raise Exception(f"Table missing: {TABLE_H7_USER}")

@st.cache_data
def check_table_state(table_name):
    table_not_found = True
    try:
        sql_stmt = f"SELECT COUNT(*) FROM {table_name}"
        df = run_sql(sql_stmt)
        table_not_found = False
    except Exception as e:
        print(str(e))

    return table_not_found
    
def check_database_state():
    st.write("[DEBUG] Checking database state")
    try:
        sql_stmt = f"SELECT COUNT(*) FROM {TABLE_H7_USER}"
        df = run_sql(sql_stmt)
        user_count = 0
        if df is not None and not df.empty:
            user_count = df.iloc[0,0]
            st.write(f"[DEBUG] Total users in database: {user_count}")

        if user_count > 0:
            sql_stmt = f"SELECT * FROM {TABLE_H7_USER}"
            df2 = run_sql(sql_stmt)
            st.dataframe(df2)
        else:
            st.write("[DEBUG] No users in database")

    except Exception as e:
        st.write(f"[DEBUG] Error checking database state: {str(e)}")

def clear_database():
    sql_stmt = f""" 
        DROP TABLE IF EXISTS {TABLE_H7_USER};
        DROP TABLE IF EXISTS {TABLE_H7_TASK};
    """
    run_sql(sql_stmt)
    st.write("[DEBUG] Database cleared")


# UI related
# ====================================
PAGE_SIZE, GRID_HEIGHT = 5, 200

# Aggrid options
# how to set column width
# https://stackoverflow.com/questions/72624323/how-to-set-a-max-column-length-for-streamlit-aggrid
_GRID_OPTIONS = {
    "paginationPageSize": 10,
    "grid_height": 350,
    "return_mode_value": DataReturnMode.__members__["FILTERED"],
    "update_mode_value": GridUpdateMode.__members__["MODEL_CHANGED"],
    "fit_columns_on_grid_load": True,
    "selection_mode": "single",  #  "multiple",  # 
    "allow_unsafe_jscode": True,
    "groupSelectsChildren": True,
    "groupSelectsFiltered": True,
    "enable_pagination": True,
}

def _display_df_grid(df, 
        selection_mode="single",  # "multiple", 
        fit_columns_on_grid_load=_GRID_OPTIONS["fit_columns_on_grid_load"],
        # min_column_width=_GRID_OPTIONS["min_column_width"],
        page_size=_GRID_OPTIONS["paginationPageSize"],
        grid_height=_GRID_OPTIONS["grid_height"],
        clickable_columns=[],
        editable_columns=[],
        colored_columns={},
        key_name="df"
    ):
    """show input df in a grid and return selected row

    URL link stopped working - see fix reported here
    https://discuss.streamlit.io/t/streamlit-aggrid-version-creating-an-aggrid-with-columns-with-embedded-urls/39640/2
    """

    gb = GridOptionsBuilder.from_dataframe(df)
    gb.configure_selection(selection_mode,
            use_checkbox=True,
            groupSelectsChildren=_GRID_OPTIONS["groupSelectsChildren"], 
            groupSelectsFiltered=_GRID_OPTIONS["groupSelectsFiltered"]
        )
    gb.configure_pagination(paginationAutoPageSize=True, 
        paginationPageSize=page_size)
    
    gb.configure_columns(editable_columns, editable=True)

    # color column
    for k,v in colored_columns.items():
        gb.configure_column(k, cellStyle=v)

    if clickable_columns:       # config clickable columns
        cell_renderer_url =  JsCode("""
            class UrlCellRenderer {
                init(params) {
                    this.eGui = document.createElement('a');
                    this.eGui.innerText = params.value;
                    this.eGui.setAttribute('href', params.value);
                    this.eGui.setAttribute('style', "text-decoration:none");
                    this.eGui.setAttribute('target', "_blank");
                }
                getGui() {
                    return this.eGui;
                }
            }
        """)

        for col_name in clickable_columns:
            gb.configure_column(col_name, cellRenderer=cell_renderer_url)


    gb.configure_grid_options(domLayout='normal')
    grid_response = AgGrid(
        df, 
        gridOptions=gb.build(),
        data_return_mode=_GRID_OPTIONS["return_mode_value"],
        update_mode=_GRID_OPTIONS["update_mode_value"],
        height=grid_height, 
        fit_columns_on_grid_load=fit_columns_on_grid_load,
        allow_unsafe_jscode=True, #Set it to True to allow jsfunction to be injected
        key=key_name
    )
 
    return grid_response


# Misc
# =====================================

def admin_job_page():
    st.subheader(STR_ADMIN_JOB)
    file_list = sorted(glob("tests/*.sql"))
    selected_script_path = st.selectbox("Select script", file_list)
    sql_stmt = open(selected_script_path).read()
    st.text_area("Review", value=sql_stmt, height=300, disabled=True)
    c1, _ = st.columns(2)
    with c1:
        USERNAME = st.text_input("USERNAME", value="H7_User1@gmail.com")
        DATA_DATE = datetime.now().strftime("%Y-%m-%d")

    sql = ""
    if USERNAME:
        sql = sql_stmt.replace("USERNAME", USERNAME).replace("DATA_DATE", DATA_DATE)
        # st.code(sql)
    if st.button(f"Run Script") and sql:
        run_sql(sql, DEBUG_SQL=False)


# Note related
# ==================================
# Function to view all data

def handle_note_form(df, username, key_name, DATA_ENTITY="Note"):
    # display note list
    grid_resp = _display_df_grid(df, key_name=key_name, clickable_columns=["url"])
    selected_rows = grid_resp['selected_rows']

    # streamlit-aggrid==1.0.5
    selected_row = None if selected_rows is None or len(selected_rows) < 1 else selected_rows.to_dict(orient='records')[0]
    # display task form
    if selected_row is None:
        v_id = v_note_name = v_url = v_note = v_note_type = v_tags = ""
        v_created_by = v_updated_by = username
        v_created_at = v_updated_at = date.today()
    else:
        v_id = selected_row.get("id") 
        v_note_name = selected_row.get("note_name")
        v_url = selected_row.get("url")
        v_note = selected_row.get("note")
        v_note_type = selected_row.get("note_type")
        v_tags = selected_row.get("tags")
        v_created_by = selected_row.get("created_by")
        v_updated_by = selected_row.get("updated_by")
        v_created_at = datetime.strptime(selected_row.get("created_at"), "%Y-%m-%d")
        v_updated_at = datetime.strptime(selected_row.get("updated_at"), "%Y-%m-%d")

    col1, col2, col3 = st.columns([3,3,2])
    with col1:
        note_name = st.text_input(COL_LABELS[TABLE_H7_NOTE]['note_name'], value=v_note_name)
        url = st.text_area(COL_LABELS[TABLE_H7_NOTE]['url'],  value=v_url)
        note_type = st.selectbox(COL_LABELS[TABLE_H7_NOTE]['note_type'], LIST_NOTE_TYPE, index=LIST_NOTE_TYPE.index(""))

    with col2:
        note = st.text_area(COL_LABELS[TABLE_H7_NOTE]['note'],  value=v_note)
        tags = st.text_area(COL_LABELS[TABLE_H7_NOTE]['tags'],  value=v_tags)

    with col3:
        id = st.text_input(COL_LABELS[TABLE_H7_NOTE]['id'],  value=v_id, disabled=True)
        # created_by = st.text_input(COL_LABELS[TABLE_H7_NOTE]['created_by'],  value=v_created_by)
        created_at = st.date_input(COL_LABELS[TABLE_H7_NOTE]['created_at'],  value=v_created_at)
        updated_by = st.text_input(COL_LABELS[TABLE_H7_NOTE]['updated_by'],  value=v_updated_by)
        updated_at = st.date_input(COL_LABELS[TABLE_H7_NOTE]['updated_at'],  value=v_updated_at)

    c_1, c_2, c_3, c_4 = st.columns([2,2,2,2])
    if selected_row is None or not v_id: 
        with c_1:
            btn_add = st.button("Add Note")

        if btn_add:
            msg = add_note(note_name, url, note_type, note, tags, created_at, username, updated_at)
            if "Record added" in msg:
                st.success(msg)
            elif "Record already exists" in msg:
                st.warning(msg)
            else:
                st.error(msg)

    else:
        delete_flag = False
        with c_1:
            btn = st.button("Update Note")
        with c_2:
            delete_flag = st.checkbox("Delete?", value=False)

        if btn:
            if delete_flag:
                delete_note_by_id(v_id, username)
                st.success(f"Note Deleted: {v_id}")
            else:
                edit_note_by_id(note_name, url, note_type, note, tags, updated_by, updated_at, v_id, username)
                st.success(f"Note Updated: {v_id}")

    with c_4:
        if df is not None and not df.empty:
            handle_export(df, DATA_ENTITY="Note") 

 

def query_all_notes(username, where_clause=" 1=1 "):
    sql_stmt = f'''
        SELECT * 
        FROM {TABLE_H7_NOTE} 
        where created_by = '{username}' and {where_clause}
        order by updated_at desc;
    '''
    return run_sql(sql_stmt)


def add_note(note_name, url, note_type, note, tags, created_at, username, updated_at):
    # query if record exists
    table_name = TABLE_H7_NOTE
    key_data = dict(table_name=table_name, note_name=note_name, url=url, note_type=note_type)
    id = query_user_keys(key_data)
    if id:
        msg = f"""Record already exists:\n
            id={id}, note_name='{note_name}', url='{url}', note_type='{note_type}'       
        """
        return msg
    
    try:
        with DBConn() as conn:
            c = conn.cursor()
            c.execute(f'''
            INSERT INTO {table_name} (note_name, url, note_type, note, tags, created_by, created_at, updated_by, updated_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (note_name, url, note_type, note, tags, username, created_at, username, updated_at))
        msg = f"Record added: note_name='{note_name}', note_type='{note_type}'"
    except Exception as e:
        msg = f"[DB-ERROR] {str(e)}"

    return msg

def delete_note_by_id(note_id, username):
    try:
        sql_stmt = f'''
            DELETE FROM {TABLE_H7_NOTE} where id={note_id} and created_by = '{username}';
        '''
        return run_sql(sql_stmt)
    except Exception as e:
        st.error(f"[DB-ERROR] {str(e)}")

def edit_note_by_id(new_note_name, new_url, new_note_type, new_note, new_tags, new_updated_by, new_updated_at, note_id, username):
    try:
        with DBConn() as conn:
            c = conn.cursor()
            c.execute(f'''
                UPDATE {TABLE_H7_NOTE} 
                SET note_name=?, url=?, note_type=?, note=?, tags=?, updated_by=?, updated_at=?
                WHERE id=? and created_by=?
            ''', (new_note_name, new_url, new_note_type, new_note, new_tags, new_updated_by, new_updated_at
                , note_id, username)
            )
            return c.fetchall()
    except Exception as e:
        st.error(f"[DB-ERROR] {str(e)}")

# Task related
# ==================================
def handle_task_form(df, username, key_name, page_size=PAGE_SIZE, grid_height=GRID_HEIGHT, DATA_ENTITY="Task"):
    # display task list
    grid_resp = _display_df_grid(df, page_size=page_size, grid_height=grid_height, key_name=key_name)


    selected_rows = grid_resp['selected_rows']

    # streamlit-aggrid==1.0.5
    selected_row = None if selected_rows is None or len(selected_rows) < 1 else selected_rows.to_dict(orient='records')[0]
    # display task form
    if selected_row is None:
        v_id = v_task_name = v_description = v_note = ""
        v_due_date = date.today() + timedelta(days=5) # .strftime("%Y/%m/%d")
        v_is_urgent = v_is_important = "N"
        v_task_group = "Personal"
        v_status = "ToDo"
        v_pct_completed = "0%"
        v_task_type = ""
        v_created_by = v_updated_by = username
        v_created_at = v_updated_at = date.today()
    else:
        v_id = selected_row.get("id") 
        v_task_name = selected_row.get("task_name")
        v_description = selected_row.get("description")
        v_note = selected_row.get("note")
        v_due_date = datetime.strptime(selected_row.get("due_date"), "%Y-%m-%d")
        v_is_urgent = selected_row.get("is_urgent")
        v_is_important = selected_row.get("is_important")
        v_task_group = selected_row.get("task_group")
        v_status = selected_row.get("status")
        v_pct_completed = selected_row.get("pct_completed")
        v_task_type = selected_row.get("task_type")
        v_created_by = selected_row.get("created_by")
        v_updated_by = selected_row.get("updated_by")
        v_created_at = datetime.strptime(selected_row.get("created_at"), "%Y-%m-%d")
        v_updated_at = datetime.strptime(selected_row.get("updated_at"), "%Y-%m-%d")

    col1, col2, col3, col4 = st.columns([2,2,2,2])
    with col1:
        task_name = st.text_input(COL_LABELS[TABLE_H7_TASK]['task_name'] + LABEL_REQUIRED, value=v_task_name)
        description = st.text_area(COL_LABELS[TABLE_H7_TASK]['description'] + LABEL_REQUIRED,  value=v_description)
        task_type = st.selectbox(COL_LABELS[TABLE_H7_TASK]['task_type'] + LABEL_REQUIRED, LIST_TASK_TYPE, index=LIST_TASK_TYPE.index(v_task_type))

    with col2:
        is_urgent = st.selectbox(COL_LABELS[TABLE_H7_TASK]['is_urgent'], LIST_Y_N, index=LIST_Y_N.index(v_is_urgent))
        is_important = st.selectbox(COL_LABELS[TABLE_H7_TASK]['is_important'], LIST_Y_N, index=LIST_Y_N.index(v_is_important))
        task_group = st.selectbox(COL_LABELS[TABLE_H7_TASK]['task_group'], LIST_TASK_GROUP, index=LIST_TASK_GROUP.index(v_task_group))
        status = st.selectbox(COL_LABELS[TABLE_H7_TASK]['status'], LIST_TASK_STATUS, index=LIST_TASK_STATUS.index(v_status))

    with col3:
        due_date = st.date_input(COL_LABELS[TABLE_H7_TASK]['due_date'],  value=v_due_date)
        pct_completed = st.selectbox(COL_LABELS[TABLE_H7_TASK]['pct_completed'], LIST_PROGRESS, index=LIST_PROGRESS.index(v_pct_completed))
        note = st.text_area(COL_LABELS[TABLE_H7_TASK]['note'],  value=v_note)

    with col4:
        id = st.text_input(COL_LABELS[TABLE_H7_TASK]['id'],  value=v_id, disabled=True)
        # created_by = st.text_input(COL_LABELS[TABLE_H7_TASK]['created_by'],  value=v_created_by)
        created_at = st.date_input(COL_LABELS[TABLE_H7_TASK]['created_at'],  value=v_created_at)
        updated_by = st.text_input(COL_LABELS[TABLE_H7_TASK]['updated_by'],  value=v_updated_by)
        updated_at = st.date_input(COL_LABELS[TABLE_H7_TASK]['updated_at'],  value=v_updated_at)

    c_1, c_2, c_3, c_4 = st.columns([2,2,2,2])
    if selected_row is None or not v_id: 
        with c_1:
            btn_add = st.button("Add Task")

        if btn_add:
            msg = add_task(task_name, description, task_group, is_urgent, is_important, status, pct_completed, due_date, task_type, note, username, created_at, username, updated_at)
            if "Record added" in msg:
                st.success(msg)
            elif "Record already exists" in msg:
                st.warning(msg)
            else:
                st.error(msg)

    else:
        delete_flag = False
        with c_1:
            btn = st.button("Update Task")
        with c_2:
            delete_flag = st.checkbox("Delete?", value=False)

        if btn:
            if delete_flag:
                delete_task_by_id(v_id, username)
                st.success(f"Task Deleted: {v_id}")
            else:
                edit_task_by_id(task_name, description, task_group, is_urgent, is_important, status, pct_completed, due_date, task_type, note, updated_by, updated_at, 
                    v_id, username)
                st.success(f"Task Updated: {v_id}")
    with c_4:
        # add download button
        if key_name in ["task_df_all"] and df is not None and not df.empty:
            handle_export(df, DATA_ENTITY)


# Function to add data
def add_task(task_name, description, task_group, is_urgent, is_important, status, pct_completed, due_date, task_type, note, created_by, created_at, updated_by, updated_at):
    # query if record exists
    table_name = TABLE_H7_TASK
    key_data = dict(table_name=table_name, task_name=task_name, task_type=task_type)
    id = query_user_keys(key_data)
    if id:
        msg = f"""Record already exists:\n
            id={id}, task_name='{task_name}', task_type='{task_type}'       
        """
        return msg

    try:
        with DBConn() as conn:
            c = conn.cursor()
            c.execute(f'''
            INSERT INTO {table_name} (task_name, description, task_group, is_urgent, is_important, status, pct_completed, due_date, task_type, note, created_by, created_at, updated_by, updated_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (task_name, description, task_group, is_urgent, is_important, status, pct_completed, due_date, task_type, note, created_by, created_at, updated_by, updated_at))
        msg = f"Record added: task_name='{task_name}', task_type='{task_type}'"
    except Exception as e:
        msg = f"[DB-ERROR] {str(e)}"

    return msg


# Function to view all data
def query_all_tasks(username, where_clause=" 1=1 "):
    sql_stmt = f'''
        SELECT * 
        FROM {TABLE_H7_TASK} 
        where created_by = '{username}' and {where_clause}
        order by updated_at desc;
    '''
    return run_sql(sql_stmt)

def query_tasks_by_ids(username, ids=[]):
    df = None 
    if not ids:
        return df 
    
    if ids:
        ids_str = ",".join([str(id) for id in ids])
        ids_clase = f" id in ({ids_str}) "

        sql_stmt = f'''
            SELECT * FROM {TABLE_H7_TASK} 
            where created_by = '{username}' 
                and {ids_clase}
            order by updated_at desc;
        '''
        return run_sql(sql_stmt)

# Function to view all task names
def query_all_task_names(username):
    sql_stmt = f'''
        SELECT task_name, id FROM {TABLE_H7_TASK} where created_by = '{username}' order by task_name;
    '''
    return run_sql(sql_stmt)

# Function to get task by name
def get_task_by_name(task_name, username):
    # TODO - escape single quote in task_name
    sql_stmt = f'''
        SELECT * FROM {TABLE_H7_TASK} where task_name='{task_name}' and created_by = '{username}' order by task_name;
    '''
    return run_sql(sql_stmt)

def get_task_by_id(task_id, username):
    sql_stmt = f'''
        SELECT * FROM {TABLE_H7_TASK} where id={task_id} and created_by = '{username}' order by task_name;
    '''
    return run_sql(sql_stmt)

# Function to get task by status
def get_task_by_status(status, username):
    sql_stmt = f'''
        SELECT * FROM {TABLE_H7_TASK} where status={status} and created_by = '{username}' order by task_name;
    '''
    return run_sql(sql_stmt)


def edit_task_by_id(new_task_name, new_description, new_task_group, new_is_urgent, new_is_important, new_status, new_pct_completed, new_due_date, new_task_type, new_note, new_updated_by, new_updated_at, id, username):
    try:
        with DBConn() as conn:
            c = conn.cursor()
            c.execute(f'''
                UPDATE {TABLE_H7_TASK} 
                SET task_name=?, description=?, task_group=?, is_urgent=?, is_important=?, status=?, pct_completed=?, due_date=?, task_type=?, note=?, updated_by=?, updated_at=?
                WHERE id=? and created_by=?
            ''', (new_task_name, new_description, new_task_group, new_is_urgent, new_is_important, new_status, new_pct_completed, new_due_date, new_task_type, new_note, new_updated_by, new_updated_at
                , id, username)
            )
            return c.fetchall()
    except Exception as e:
        st.error(f"[DB-ERROR] {str(e)}")

def delete_task_by_id(task_id, username):
    try:
        sql_stmt = f'''
            DELETE FROM {TABLE_H7_TASK} where id={task_id} and created_by = '{username}';
        '''
        return run_sql(sql_stmt)
    except Exception as e:
        st.error(f"[DB-ERROR] {str(e)}")


def parse_task_id(task_string):
	# Regular expression pattern
	pattern = r'^(.*?)\s*\[(\d+)\]$'
	
	# Try to match the pattern
	match = re.match(pattern, task_string)
	
	if match:
		# If there's a match, extract the groups
		task_name = match.group(1).strip()
		task_id = int(match.group(2))
		return task_name, task_id
	else:
		# If no match, return None for both values
		return None, None

# User related
# ==================================
# Modified add_user function
def add_user(email, password, username, is_admin=0, is_active=1, profile="", note=""):
    # query if record exists
    table_name = TABLE_H7_USER
    key_data = dict(table_name=table_name, email=email, username=username)
    id = query_user_keys(key_data)
    if id:
        msg = f"""Record already exists:\n
            id={id}, email='{email}', username='{username}'       
        """
        return msg

    try:
        # hashed_password = hash_password_sha256(password)
        hashed_password = hash_password(password)
        now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        if is_first_user():
            is_admin = 1

        with DBConn() as conn:
            c = conn.cursor()
            c.execute(f'''
            INSERT INTO {table_name} (email, username, password, is_admin, is_active, profile, note, created_by, created_at, updated_by, updated_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (email, username, hashed_password, is_admin, is_active, profile, note, email, now, email, now))
        msg = f"Record added: email='{email}', username='{username}'"

    except PasswordError as e:
        msg = f"Password error: {str(e)}"
    except Exception as e:
        msg = f"[DB-ERROR] {str(e)}"

    return msg

# Function to get all users
def query_all_users():
    sql_stmt = f"SELECT id, email, username, is_admin, is_active, profile, note FROM {TABLE_H7_USER} order by email"
    df = run_sql(sql_stmt)
    return df


# Function to update user
def update_user(username, email, is_admin, is_active, profile, note):
    now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    try:
        with DBConn() as conn:
            c = conn.cursor()        
            c.execute(f'''
            UPDATE {TABLE_H7_USER}
            SET email=?, is_admin=?, is_active=?, profile=?, note=?, updated_at=?
            WHERE username=?
            ''', (email, is_admin, is_active, profile, note, now, username))
    except Exception as e:
        st.error(f"[DB-ERROR] {str(e)}")        

# Function to get user by id
def get_user_by_username(username):
    with DBConn() as conn:
        c = conn.cursor()      
        c.execute(f"SELECT * FROM {TABLE_H7_USER} WHERE username = ?", (username,))
        return c.fetchone()

# New function for the Edit User page
def edit_user_page(username, is_admin):
    st.subheader(STR_EDIT_USER)
    user = get_user_by_username(username)
    if user:
        c1, c2,c3 = st.columns([4,4,2])
        with c1:
            email = st.text_input("Email", value=user[1])
            profile = st.text_area("Profile", value=user[6] or "")

        with c2:
            username = st.text_input("Username", value=user[3])
            note = st.text_area("Note", value=user[7] or "")            

        with c3:
            if is_admin:
                is_admin_flag = st.checkbox("Is Admin", value=bool(user[4]))
                is_active = st.checkbox("Is Active", value=bool(user[5]))
            else:
                is_admin_flag = user[4]
                is_active = user[5]

        if st.button("Update"):
            update_user(username, email, int(is_admin_flag), int(is_active), profile, note)
            st.success("User updated successfully")
            st.rerun()

# New function for the Add User page (admin only)
def new_user_page():
    st.subheader("New User")
    col_name = 'email'
    email = st.text_input(COL_LABELS[TABLE_H7_USER][col_name])
    col_name = 'username'
    username = st.text_input(COL_LABELS[TABLE_H7_USER][col_name])
    col_name = 'password'
    password = st.text_input(COL_LABELS[TABLE_H7_USER][col_name], type="password")
    confirm_password = st.text_input(f"Confirm {COL_LABELS[TABLE_H7_USER][col_name]}", type="password")
    col_name = 'is_admin'
    is_admin = st.checkbox(COL_LABELS[TABLE_H7_USER][col_name])
    col_name = 'is_active'
    is_active = st.checkbox(COL_LABELS[TABLE_H7_USER][col_name], value=True)
    col_name = 'profile'
    profile = st.text_area(COL_LABELS[TABLE_H7_USER][col_name])
    col_name = 'note'
    note = st.text_area(COL_LABELS[TABLE_H7_USER][col_name])

    if st.button(STR_ADD_USER):
        if password != confirm_password:
            st.error("Passwords do not match")
        elif email_exists(email):
            st.error("Email already exists")
        else:
            add_user(email, password, username, int(is_admin), int(is_active), profile, note)
            st.success("User added successfully")

# New function for the Manage Users page (admin only)
def manage_users_page():
    st.subheader(STR_MANAGE_USER)
    df = query_all_users()
    grid_resp = _display_df_grid(df, key_name=f"{TABLE_H7_USER}_grid")

    selected_rows = grid_resp['selected_rows']
    if selected_rows is not None and not selected_rows.empty:
        selected_user = selected_rows.iloc[0]
        st.subheader(f"Edit User: {selected_user['username']}")
        c1, c2 = st.columns(2)
        with c1:
            col_name = 'email'
            email = st.text_input(COL_LABELS[TABLE_H7_USER][col_name], value=selected_user[col_name])
            col_name = 'username'
            username = st.text_input(COL_LABELS[TABLE_H7_USER][col_name], value=selected_user[col_name])
            col_name = 'profile'
            profile = st.text_area(COL_LABELS[TABLE_H7_USER][col_name], value=selected_user[col_name])

        with c2:
            col_name = 'id'
            user_id = st.text_input(COL_LABELS[TABLE_H7_USER][col_name], value=selected_user[col_name], disabled=True)
            col_name = 'is_admin'
            is_admin = st.checkbox(COL_LABELS[TABLE_H7_USER][col_name], value=bool(selected_user[col_name]))
            col_name = 'is_active'
            is_active = st.checkbox(COL_LABELS[TABLE_H7_USER][col_name], value=bool(selected_user[col_name]))
            col_name = 'note'
            note = st.text_area(COL_LABELS[TABLE_H7_USER][col_name], value=selected_user[col_name])

        if st.button("Update"):
            update_user(username, email, int(is_admin), int(is_active), profile, note)
            st.success("User updated successfully")
            st.rerun()

# Function to hash password
def hash_password_sha256(password):
    return hashlib.sha256(str.encode(password)).hexdigest()

class PasswordError(Exception):
    """Custom exception for password-related errors"""
    pass

def validate_password_strength(password: str) -> Tuple[bool, Optional[str]]:
    """
    Validate password strength against security requirements.
    
    Requirements:
    - Minimum 8 characters
    - At least one uppercase letter
    - At least one lowercase letter
    - At least one number
    - At least one special character
    
    Args:
        password: The password to validate
        
    Returns:
        Tuple[bool, Optional[str]]: (is_valid, error_message)
    """
    if len(password) < 8:
        return False, "Password must be at least 8 characters long"
    
    if not re.search(r"[A-Z]", password):
        return False, "Password must contain at least one uppercase letter"
    
    if not re.search(r"[a-z]", password):
        return False, "Password must contain at least one lowercase letter"
    
    if not re.search(r"\d", password):
        return False, "Password must contain at least one number"
    
    if not re.search(r"[!@#$%^&*(),.?\":{}|<>]", password):
        return False, "Password must contain at least one special character"
    
    return True, None

def hash_password(password: str) -> bytes:
    """
    Hash a password using bcrypt with salt.
    
    Args:
        password: The plain text password to hash
        
    Returns:
        bytes: The hashed password with salt
        
    Raises:
        PasswordError: If password doesn't meet strength requirements
    """
    # First validate password strength
    is_valid, error_message = validate_password_strength(password)
    if not is_valid:
        raise PasswordError(error_message)
    
    # Generate a salt and hash the password
    # WorkFactor of 12 is considered secure as of 2024 while still being reasonably fast
    salt = bcrypt.gensalt(rounds=12)
    hashed = bcrypt.hashpw(password.encode('utf-8'), salt)
    return hashed

def verify_password(password: str, hashed_password: bytes) -> bool:
    """
    Verify a password against a hashed password.
    
    Args:
        password: The plain text password to verify
        hashed_password: The hashed password to check against
        
    Returns:
        bool: True if password matches, False otherwise
    """
    try:
        return bcrypt.checkpw(password.encode('utf-8'), hashed_password)
    except Exception:
        return False

# Function to verify user
def verify_user(email, password):
    # hashed_password = hash_password_sha256(password)
    try:
        with DBConn() as conn:
            c = conn.cursor()
            c.execute(f"SELECT * FROM {TABLE_H7_USER} WHERE email = ? AND is_active = 1", (email, ))
            user = c.fetchone()
            if user and verify_password(password, user[3]):  # user[3] is the hashed password (see table DDL statement)
                return user
            return None
    except Exception as e:
        st.error(f"[DB-ERROR] {str(e)}")

# Function to check if email exists
def email_exists(email):
    with DBConn() as conn:
        c = conn.cursor()
        c.execute(f"SELECT * FROM {TABLE_H7_USER} WHERE email = ?", (email,))
        user = c.fetchone()
        return user is not None

# Login page
def login_page():
    st.subheader("Login")
    email = st.text_input("Email")
    password = st.text_input("Password", type="password")
    if st.button("Login"):
        user = verify_user(email, password)
        st.write(user)
        if user:
            st.session_state['logged_in'] = True
            st.session_state['user_id'] = user[0]  # id
            user_name = user[2]                    # username
            st.session_state['username'] = user_name
            st.session_state['is_admin'] = bool(user[4])
            st.success(f"Logged in as {user_name}, user_id={user[0]}")
            st.rerun()
        else:
            st.error("Incorrect email or password or account is inactive")

# Registration page
def registration_page():
    st.subheader("Register")
    
    email = st.text_input("Email")
    username = st.text_input("Username")
    password = st.text_input("Password", type="password")
    confirm_password = st.text_input("Confirm Password", type="password")
    
    if st.button("Register"):      
        if password != confirm_password:
            st.error("Passwords do not match")
        elif email_exists(email):
            st.error("Email already exists")
        else:
            try:
                add_user(email, password, username)
                st.success("Registration successful. Please login.")
                # check_database_state()  # Check the database state after registration
            except Exception as e:
                st.error(f"An error occurred during registration: {str(e)}")
                # check_database_state()  # Check the database state even if there's an error

# Main app logic
# ================================
def main(DEBUG_FLAG = False):
    st.sidebar.subheader("7 Habits Task Manager")
   
    if DEBUG_FLAG:
        # Display debug information
        user_count = 0
        sql_stmt = f"SELECT COUNT(*) FROM {TABLE_H7_USER}"
        df = run_sql(sql_stmt)
        if df is not None and not df.empty:
            user_count = df.iloc[0,0]
            st.write(f"[DEBUG] Total users: {user_count}")
        
        if user_count > 0:
            sql_stmt = f"SELECT COUNT(*) FROM {TABLE_H7_USER} WHERE is_admin = 1"
            df = run_sql(sql_stmt)
            if df is not None and not df.empty:
                admin_count = df.iloc[0,0]
                st.write(f"[DEBUG] Admin users: {admin_count}")

    # Initialize session state
    if 'logged_in' not in st.session_state:
        st.session_state['logged_in'] = False

    # Sidebar for login/logout
    if st.session_state['logged_in']:
        st.sidebar.success(f"Logged in as: {st.session_state['username']}")
        if st.sidebar.button("Logout"):
            init_session_state()
            st.rerun()
    else:
        auth_option = st.sidebar.radio("Choose an option", ["Login", "Register"])
        if auth_option == "Login":
            login_page()
        else:
            registration_page()

    # Only show the app if logged in
    if not st.session_state['logged_in']:
        return
    
    username = st.session_state['username']
    is_admin = st.session_state['is_admin']
    if is_admin:
        menu_admin = [
            STR_ADD_USER, 
            STR_MANAGE_USER, 
            STR_ADMIN_JOB
        ] 
        MENU_ITEMS.extend(menu_admin)

    # handle page selection
    choice = st.sidebar.selectbox("Menu", MENU_ITEMS)

    if choice == STR_HOME:
        st.subheader(STR_HOME)
        st.write("Welcome to the 7 Habits Task Manager. Use the sidebar to navigate through the app.")
        st.write("[Learn more about the 7 Habits of Highly Effective People](https://en.wikipedia.org/wiki/The_7_Habits_of_Highly_Effective_People)")

    elif choice == STR_MANAGE_NOTE:
        st.subheader(STR_MANAGE_NOTE)
        DATA_ENTITY = "NOTE"
       # allow search
        c_keyword, c_note_type = st.columns([3,1])
        with c_keyword:
            q_keyword = st.text_input("üîçKeyword:", key=f"{DATA_ENTITY}_keyword")
            q_keyword = sanitize_search_input(q_keyword.strip())
        with c_note_type:
            note_type_options = LIST_NOTE_TYPE
            q_note_type = st.selectbox("Note Type", note_type_options, index=note_type_options.index(BLANK_STR_VALUE), key=f"{DATA_ENTITY}_note_type")
        where_clause = " 1=1 " 
        if q_keyword:
            where_clause += f""" and (
                    note_name like '%{q_keyword}%'
                    OR url like '%{q_keyword}%'
                    OR note like '%{q_keyword}%'
                    OR tags like '%{q_keyword}%'
                ) """
        if q_note_type:
            where_clause += f""" and note_type = '{q_note_type}' """

        df = query_all_notes(username, where_clause=where_clause)
        handle_note_form(df, username, key_name="note_df_all")

    elif choice == STR_MANAGE_TASK:
        st.subheader(STR_MANAGE_TASK)
        DATA_ENTITY = "TASK"
        # allow search
        c_keyword, c_task_group, c_task_type, c_status, c_urgent, c_important = st.columns([1,1,1,1,1,1])
        with c_keyword:
            q_keyword = st.text_input("üîçKeyword:", key=f"{DATA_ENTITY}_keyword")
            q_keyword = sanitize_search_input(q_keyword.strip())
        with c_task_group:
            task_group_options = [BLANK_STR_VALUE] + LIST_TASK_GROUP
            q_task_group = st.selectbox("Task Group", task_group_options, index=task_group_options.index(BLANK_STR_VALUE), key=f"{DATA_ENTITY}_task_group")
        with c_task_type:
            task_type_options = LIST_TASK_TYPE
            q_task_type = st.selectbox("Task Type", task_type_options, index=task_type_options.index(BLANK_STR_VALUE), key=f"{DATA_ENTITY}_task_type")
        with c_status:
            status_options = [BLANK_STR_VALUE] + LIST_TASK_STATUS
            q_status = st.selectbox("Status", status_options, index=status_options.index(BLANK_STR_VALUE), key=f"{DATA_ENTITY}_status")
        with c_urgent:
            urgent_options = [BLANK_STR_VALUE] + LIST_Y_N
            q_urgent = st.selectbox("Urgent", urgent_options, index=urgent_options.index(BLANK_STR_VALUE), key=f"{DATA_ENTITY}_urgent")
        with c_important:
            important_options = [BLANK_STR_VALUE] + LIST_Y_N
            q_important = st.selectbox("Important", important_options, index=important_options.index(BLANK_STR_VALUE), key=f"{DATA_ENTITY}_important")

        where_clause = " 1=1 " 
        if q_keyword:
            where_clause += f""" and (
                    task_name like '%{q_keyword}%'
                    OR description like '%{q_keyword}%'
                    OR note like '%{q_keyword}%'
                ) """
        if q_task_group:
            where_clause += f""" and task_group = '{q_task_group}' """
        if q_task_type:
            where_clause += f""" and task_type = '{q_task_type}' """
        if q_status:
            where_clause += f""" and status = '{q_status}' """
        if q_urgent:
            where_clause += f""" and is_urgent = '{q_urgent}' """
        if q_important:
            where_clause += f""" and is_important = '{q_important}' """

        df = query_all_tasks(username, where_clause=where_clause)
        handle_task_form(df, username, 
                        page_size=_GRID_OPTIONS["paginationPageSize"], 
                        grid_height=_GRID_OPTIONS["grid_height"],                          
                        key_name="task_df_all")
    

    elif choice == STR_HABITS_7_TASK:
        st.subheader("7 Habits View")

        # Filters
        f_1, f_2 = st.columns(2)
        with f_1:
            selected_task_groups = st.multiselect("Filter by Task Group", LIST_TASK_GROUP, default=["Personal"])
        with f_2:
            selected_statuses = st.multiselect("Filter by Status", LIST_TASK_STATUS, default=["ToDo", "Doing"])

        # Fetch all tasks
        df_all = query_all_tasks(username)
        # Apply filters
        df = df_all[(df_all['task_group'].isin(selected_task_groups)) & (df_all['status'].isin(selected_statuses))]
        selected_cols = ["task_name", "status", "task_group", "description", "id"]

        selected_ids = []
        # Display quadrants in a 2x2 grid layout
        row1_col1, row1_col2 = st.columns(2)
        with row1_col1:
            st.markdown("##### Un-Important/Urgent (ii)")
            df_2 = df[(df['is_important'] == 'N') & (df['is_urgent'] == 'Y')][selected_cols]
            grid_resp_2 = _display_df_grid(df_2, key_name="df_2", page_size=PAGE_SIZE, grid_height=GRID_HEIGHT)
            selected_rows_2 = grid_resp_2['selected_rows']
            if selected_rows_2 is not None and not selected_rows_2.empty:
                selected_ids += selected_rows_2["id"].to_list()

        with row1_col2:
            st.markdown("##### Important/Urgent (i)")
            df_1 = df[(df['is_important'] == 'Y') & (df['is_urgent'] == 'Y')][selected_cols]
            grid_resp_1 = _display_df_grid(df_1, key_name="df_1", page_size=PAGE_SIZE, grid_height=GRID_HEIGHT)
            selected_rows_1 = grid_resp_1['selected_rows']
            if selected_rows_1 is not None and not selected_rows_1.empty:
                selected_ids += selected_rows_1["id"].to_list()

        row2_col1, row2_col2 = st.columns(2)
        with row2_col1:
            st.markdown("##### Un-Important/Un-Urgent (iii)")
            df_3 = df[(df['is_important'] == 'N') & (df['is_urgent'] == 'N')][selected_cols]
            grid_resp_3 = _display_df_grid(df_3, key_name="df_3", page_size=PAGE_SIZE, grid_height=GRID_HEIGHT)
            selected_rows_3 = grid_resp_3['selected_rows']
            if selected_rows_3 is not None and not selected_rows_3.empty:
                selected_ids += selected_rows_3["id"].to_list()

        with row2_col2:
            st.markdown("##### Important/Un-Urgent (iv)")
            df_4 = df[(df['is_important'] == 'Y') & (df['is_urgent'] == 'N')][selected_cols]
            grid_resp_4 = _display_df_grid(df_4, key_name="df_4", page_size=PAGE_SIZE, grid_height=GRID_HEIGHT)
            selected_rows_4 = grid_resp_4['selected_rows']
            if selected_rows_4 is not None and not selected_rows_4.empty:
                selected_ids += selected_rows_4["id"].to_list()

        if selected_ids:
            # st.write(selected_ids)
            df_selected = query_tasks_by_ids(username, ids=selected_ids)
            if df_selected is not None and not df_selected.empty:
                # st.dataframe(df_selected)
                handle_task_form(df_selected, username, key_name="task_df_selected")

    elif choice == STR_EDIT_USER:
        edit_user_page(username, is_admin)

    else:
        if is_admin:
            if choice == STR_ADD_USER:
                new_user_page()

            elif choice == STR_MANAGE_USER:
                manage_users_page()

            elif choice == STR_ADMIN_JOB:
                admin_job_page()

if __name__ == '__main__':
    create_tables()
    main()